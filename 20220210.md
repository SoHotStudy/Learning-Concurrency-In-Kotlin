# 코틀린 동시성 프로그래밍 Study

토론 주책임자 - 강현식

## 1장
프로세스/스레드 에 대한 기본 설명
### 핵심 내용 및 토론
* UI 프로그램에 대입해 이야기 하고 있다. 사용자에게 노출될 스레드는 블로킹을 하지 않아야 한다.
* 사용자에게 노출되지 않을 스레드라면 블로킹 되는건 그럼 전혀 문제가 없을까?
* 코틀린 코루틴은 스레드를 직접 시작할 필요가 없다고 이야기 한다 - 이부분이 다른 스레드 처리 방식과의 가장 큰 차이점
* 그러나 실제 코루틴도 startCoroutine 메소드와 같은 코루틴의 시작 메소드는 있다. 스레드가 아니고 코루틴일뿐...
* 코틀린은 경량 스레드이다 라고 공식 문서에 되어있지만 공식 문서가 매우 틀린 내용을 기술하고 있어 오해의 여지가 있다
* 코루틴은 경량 스레드가 아니라 경량 스레드처럼 동작하게 해주는 장치일 뿐이다
* 코루틴의 흥미로운점.. 스레드와 강한 결합하지 않고 아주 약한 결합을 가지고 있다. 그래서 디버깅하기 간단치는 않다. 향후 프로덕션에 적용할때 가장 주의해야할 지점
* 동시성과 병렬성에 대해 별 생각이 없었지만 코루틴을 사용해보면 매우 다름을 더 자세히 깨달을 수 있다. 1개 메인 스레드로도 수많은 스레드를 돌리는것과 같은 효과가 가능하다
* 동시성이 어려운 이유에 대해... 사실 동시성이 어려운건 사람의 머리는 1개인데 여러개인것처럼 만들어야 하는게 가장 괴리감이 오는게 아닌가 싶다
* suspend 함수는 중단 가능한 함수를 의미하는데 코틀린의 코루틴을 처음 보면 이게 무조건 async 로 실행 된다는건가? 하는 착각을 할 때가 있다
* 많은 코루틴 소개 예제를 보면 async {...} 보다는 그냥 suspend 메소드 호출하면 이게 중단되었다 재개되는거야~ 이런 느낌의 설명만 있고 이게 왜 유용한지 
 이걸 어떻게 async 로 바꿔서 기존의 스레드 프로그래밍 하던 개발자들과의 간격을 좁힐지에 대해서는 설명이 없는데 이 책은 그부분부터 시작해서 좋은것 같다
* 채널/액터 등을 설명하고 있긴 한데 실제로 코루틴 사용할때 거의 안 썼던것 같은데.. 실제 코루틴을 많이 쓰는곳에서는 어떻게 쓰는지 궁금하다
* suspend 를 만나면 일시 중단한다고만 되어있는데 이부분에 대한 세부 동작 설명이 9장까지나 가야 알 수 있으니 너무 멀리 가야하는것 같다.
* 코루틴의 디스패쳐가 좀 특이한 녀석으로.. 실제 스레드 풀하고 매칭이 되기도 하고(IO 등) 그렇지 않기도(Unconfined) 하다
* runBlocking .. 실제 사용하면 안되는 안티패턴이지만 아래 두가지 사례에서 사용 가능
 자동화 테스트 - 코드 테스트를 위해서 진입점을 주기 위한 시작점으로
 코루틴 전환중인 프로젝트 - 전체 구간을 suspend 로 바꾸는건 어려울 수 있다. 중간부분이라도 조금씩 바꿀때 사용하면 유용
 
## 2장
coroutine in action

## 핵심 내용 및 토론 내용

* 코루틴이 예전에는 experimental 이었다가 1.3부터 정식으로 포함되었다
* async 를 비롯한 코루틴 빌더에 항상 scope 가 필요해졌다(이부분 좀 불편한데 명시적이어서 올바른것 방향 같긴 함)
* join, await 는 각각 예외 비전파/전파의 차이가 있다. 가급적이면 await 를 쓰는게 좋지 않을까?
 코루틴 홈페이지 설명을 보면 동시성 프로그램을 try catch 로 가능하다는게 장점으로 나올 정도이니.. 예외 처리는 동시성 프로그래밍의 큰 허들중 하나이다. 그러므로 우린 await 를 쓰는게 어떨까?
* fire and forget 전략(launch)는 네트워크가 들어가면 크게 문제가 되는 경우가 있어서 개인적으로는 별로 선호하는 방식은 아니다
* 81페이지의 main 부터 runBlocking 으로 시작하면 suspend 로 시작하기 때문에 코루틴을 쓰기가 매우 좋으나, 우리는 스프링과 같은 프레임워크를 사용하고 있으니 사실상 불가능한 전략이다.
 그러나 controller 부터 suspend 로 작성하면 유사한 결과를 얻어낼 수 있다. 물론 그 안의 모든 호출 메소드를 suspend 로 바꿔야 하는 불편함은 여전히 존재
* UI 가 블로킹되는 부분에 대한 이야기가 나오는데 우리의 경우 컨트롤러가 실행되는 스레드 안에서 블로킹이 일어나는 상황과 동일하게 대입해보면 될것 같다
* 여기서 또 재밌는 방식인 일반 function 에서 같은 스레드에서 suspend 방식 호출을 가능케 하는 방법이 나온다 GlobalScope.launch(현재스레드디스패쳐) 인데.. 우리가 향후 전환할때 써먹을 수 있을 것 같다.
