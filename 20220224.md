주토론자: 김성윤

# 05. 이터레이터, 시퀀스, 그리고 프로듀서 (일시 중단 데이터 소스)

데이터 소스를 일시 중단 함수와 비동기 함수로 구현

- 일시 중단 가능한 시퀀스
- 일시 중단 가능한 이터레이터
- 시퀀스와 이터레이터의 차이점
- 프로듀서를 사용한 비동기 데이터 검색
- 프로듀서의 실제 사례

## 1) 일시 중단 가능한 시퀀스 및 이터레이터

- 일시 중단 가능한 시퀀스와 이터레이터
    - `호출 사이`에서는 `일시 중단`, `실행 중`에는 `일시 중단 될 수 없음` ⇒ 일시 중단 불가능한 코드에서 호출 가능
    - 시퀀스와 이터레이터 빌더는 `CoroutineContext X` (코드 호출 컨텍스트와 동일한 컨텍스트에서 실행)
    - 정보 산출(yield) 후 값이 다시 요청될 때 까지 일시 중단
- 값을 생성한 후(호출 사이)에는 일시 중단 될 수 있지만, 실행 중에는 일시 중단 될 수 없으므로 `숫자의 시퀀스와 같은 비동기 작업이 필요 없는 데이터 소스`에 적합

## 2) 이터레이터

### 특징

컬렉션을 `순서대로` 살펴보는 데 유용

- 인덱스로 검색할 수 없고 순서대로만 액세스
- 요소는 한 방향으로만 검색 (이전 요소 검색 불가)
- 재설정(reset) 할 수 없으므로 한 번만 반복 가능

### 상호 작용

- 모든 요소 읽기 (전체 이터레이터 반복): `forEach()`, `forEachRemaining()`
- 다음 값 가져오기: `next()` (요소가 없다면 NoSuchElementException)
- 요소가 더 있는지 검증하기: `hasNext()` (호출 시점에 코루틴 실행을 재개, 값 산출, `next()` 호출 시점에 반환)

## 3) 시퀀스

### 특징

- 인덱스로 값을 가져올 수 있음
- 상태가 저장되지 않으며, 상호 작용한 후 자동으로 재설정(reset)

```kotlin
val sequence = sequence {
	for (i in 0..9) {
    println("$i")
		yield(i)
  }
}

fun main() {
  sequence.elementAt(1)             // 0 1
  sequence.elementAt(2)             // 0 1 2
  sequence.take(3).joinToString()   // 0 1 2
}
```

- 한 번의 호출로 요소 그룹을 가져올 수 있음

### 상호작용

- 모든 요소 읽기 (전체 시퀀스 반복): `forEach()`, `forEachIndexed()`
- 특정 요소 얻기: `elementAt()`, `elementAtOrElse()`, `elementAtOrNull()`
- 요소 그룹 얻기: `take()`

```kotlin
// take()는 중간 연산, joinToString() 종단 연산 실행 시점에 Sequence<T> 반환
val firstFive = sequence.take(5)
println(firstFive.joinToString())
```

### 일시 중단 피보나치

요청 시 시퀀스에서 숫자를 반환, `호출 사이`에는 `일시 중단 상태`를 유지하는 함수

```kotlin
val fibonacci = sequence {
	yield(1)
  var current = 1
  var next = 1
  while(true) {
    yield(next)
    val tmpNext = current + next
    current = next
    next = tmpNext
  }
}
```

- 첫 번째 숫자 1을 산출하고 시퀀스 중단
- 두 번째 숫자 요청 시 무한 루프 돌입, next 값 산출하고 시퀀스 중단

## 4) 프로듀서

시퀀스, 이터레이터: 실행 중 `일시 중단할 수 없음`

프로듀서: 다른 작업이 끝나기를 기다리는 동안 `일시 중단 할 수 있음`

### 특징

- 값이 생성된 후 일시 중단, 새로운 값이 요청될 때 다시 재개 (시퀀스, 이터레이터와 동일)
- `특정 CoroutineContext`로 생성 가능
- 일시 중단 람다는 `언제든지 일시 중단` 될 수 있음 ⇒ 프로듀서 값은 일시 중단 연산에서만 수신 가능
- `채널`을 사용해 동작 (데이터를 스트림 처럼. 요소를 수신하면 스트림에서 요소가 제거)

### 프로듀서 만들기

- `produce()` 코루틴 빌더로 생성, ReceiverChannel<E> 반환
- 채널 위에 구축. 요소를 산출하기 위해 `send(E)`사용

```kotlin
val context = newSingleThreadContext("myThread")
val producer = GlobalScope.produce(context) {
  send(1)
}
```

### 상호작용

- 모든 요소 읽기: `consumeEach()`
- 단일 요소 얻기: `receive()`
- 요소 그룹 얻기: `take()` (중간 연산, ReceiveChannel<E> 반환)
- 더 이상 요소가 없다면 중지 (채널이 닫힘)

### 예제 (온디맨드 RSS 리더)

```kotlin
// ArticleProducer.kt
object ArticalProducer {
  private val feeds = listOf(
    Feed("cnn", "cnn rss url")
  )
  private val dispatcher = newFixedThreadPoolContext(2, "IO")
  private val factory = DocumentBuilderFactory.newInstance()

  // 해당 피드의 기사 리스트 반환
  private fun fetchArticles(feed: Feed): List<Article> {
    val builder = factory.newDocumentBuilder()
    val xml = builder.parse(feed.url)
    val news = xml.getElementsByTagName("channel").item(0)

    return (0 until news.childNodes.length)
      .map{ news.childNodes.item(it) }
      .filter { Node.ELEMENT_NODE == it.nodeType }
      .map { it as Element }
  }

  // 프로듀서는 특정 CoroutineContext로 생성 가능
  val producer = GlobalScope.produce(dispatcher) {
    feeds.forEach {
      send(fetchArticles(it))
    }
  }
}

interface ArticleLoader {
  // 가능한 더 많은 기사를 로드하는 일시 중단 함수
  // 프로듀서 값은 일시 중단 연산에서만 수신 가능
  suspend fun loadMore()
}

class Activity: ArticleLoader {
  override suspend fun loadMore() {
    val producer = ArticleProducer.producer

    // 프로듀서가 닫혀 있는지 검사
    if (!producer.isClosedForReceive) {
      val articles = producer.receive()

      launch(UI) {
        // UI에 articles 표시
      }  
  }
}
```
